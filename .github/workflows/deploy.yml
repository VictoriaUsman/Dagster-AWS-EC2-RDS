name: Deploy dbt + Dagster to EC2

on:
  push:
    branches: [main]

env:
  REMOTE_DIR: /home/ec2-user/car_sales
  EC2_USER: ec2-user
  SSH_OPTS: -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=15 -o ServerAliveCountMax=3

jobs:
  test:
    name: Validate dbt project
    runs-on: ubuntu-latest
    env:
      RDS_PG_HOST: ${{ secrets.RDS_PG_HOST }}
      RDS_PG_PORT: ${{ secrets.RDS_PG_PORT }}
      RDS_PG_DATABASE: ${{ secrets.RDS_PG_DATABASE }}
      RDS_PG_USER: ${{ secrets.RDS_PG_USER }}
      RDS_PG_PASSWORD: ${{ secrets.RDS_PG_PASSWORD }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip

      - name: Install dbt
        run: pip install dbt-postgres

      - name: Compile dbt project
        working-directory: car_sales_dbt
        run: dbt compile --profiles-dir .

  deploy:
    name: Deploy to EC2
    needs: test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/ec2_key.pem
          chmod 600 ~/.ssh/ec2_key.pem

      - name: Verify SSH connectivity
        env:
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          for i in 1 2 3; do
            if ssh -i ~/.ssh/ec2_key.pem ${{ env.SSH_OPTS }} ${{ env.EC2_USER }}@${HOST} "echo ok"; then
              echo "SSH connection established"
              exit 0
            fi
            echo "SSH attempt $i failed, retrying in 10s..."
            sleep 10
          done
          echo "::error::Failed to connect to EC2 after 3 attempts"
          exit 1

      - name: Copy project files to EC2
        env:
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          SSH="ssh -i ~/.ssh/ec2_key.pem ${{ env.SSH_OPTS }} ${{ env.EC2_USER }}@${HOST}"
          SCP="scp -i ~/.ssh/ec2_key.pem ${{ env.SSH_OPTS }}"
          REMOTE=${{ env.REMOTE_DIR }}

          # Create a staging dir so the deploy is atomic — old files stay until new ones land
          ${SSH} "mkdir -p ${REMOTE}/_staging"
          ${SCP} -r car_sales_dbt    "${{ env.EC2_USER }}@${HOST}:${REMOTE}/_staging/"
          ${SCP} -r car_sales_dagster "${{ env.EC2_USER }}@${HOST}:${REMOTE}/_staging/"
          ${SCP}    requirements_ec2.txt "${{ env.EC2_USER }}@${HOST}:${REMOTE}/_staging/"

          # Swap atomically: remove old, move new into place
          ${SSH} "rm -rf ${REMOTE}/car_sales_dbt ${REMOTE}/car_sales_dagster ${REMOTE}/requirements_ec2.txt \
                  && mv ${REMOTE}/_staging/car_sales_dbt ${REMOTE}/ \
                  && mv ${REMOTE}/_staging/car_sales_dagster ${REMOTE}/ \
                  && mv ${REMOTE}/_staging/requirements_ec2.txt ${REMOTE}/ \
                  && rmdir ${REMOTE}/_staging"

      - name: Install packages on EC2
        env:
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          SSH="ssh -i ~/.ssh/ec2_key.pem ${{ env.SSH_OPTS }} ${{ env.EC2_USER }}@${HOST}"
          REMOTE=${{ env.REMOTE_DIR }}
          ${SSH} "cd ${REMOTE} && pip3 install --quiet -r requirements_ec2.txt && cd car_sales_dagster && pip3 install --quiet -e ."

      - name: Write .env file
        env:
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          # Build .env content locally where we control quoting, then upload
          cat > /tmp/deploy.env << 'HEADER'
          HEADER

          # Append each secret as KEY=VALUE with proper quoting
          {
            echo "SOURCE_PG_HOST='${{ secrets.SOURCE_PG_HOST }}'"
            echo "SOURCE_PG_PORT='${{ secrets.SOURCE_PG_PORT }}'"
            echo "SOURCE_PG_DATABASE='${{ secrets.SOURCE_PG_DATABASE }}'"
            echo "SOURCE_PG_USER='${{ secrets.SOURCE_PG_USER }}'"
            echo "SOURCE_PG_PASSWORD='${{ secrets.SOURCE_PG_PASSWORD }}'"
            echo "S3_BUCKET='${{ secrets.S3_BUCKET }}'"
            echo "S3_REGION='${{ secrets.S3_REGION }}'"
            echo "S3_KEY='${{ secrets.S3_KEY }}'"
            echo "RDS_PG_HOST='${{ secrets.RDS_PG_HOST }}'"
            echo "RDS_PG_PORT='${{ secrets.RDS_PG_PORT }}'"
            echo "RDS_PG_DATABASE='${{ secrets.RDS_PG_DATABASE }}'"
            echo "RDS_PG_USER='${{ secrets.RDS_PG_USER }}'"
            echo "RDS_PG_PASSWORD='${{ secrets.RDS_PG_PASSWORD }}'"
          } >> /tmp/deploy.env

          SCP="scp -i ~/.ssh/ec2_key.pem ${{ env.SSH_OPTS }}"
          ${SCP} /tmp/deploy.env "${{ env.EC2_USER }}@${HOST}:${{ env.REMOTE_DIR }}/.env"
          rm -f /tmp/deploy.env

      - name: Configure AWS credentials on EC2
        env:
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          SSH="ssh -i ~/.ssh/ec2_key.pem ${{ env.SSH_OPTS }} ${{ env.EC2_USER }}@${HOST}"
          ${SSH} "mkdir -p ~/.aws \
            && printf '[default]\naws_access_key_id = %s\naws_secret_access_key = %s\n' \
               '${{ secrets.AWS_ACCESS_KEY_ID }}' '${{ secrets.AWS_SECRET_ACCESS_KEY }}' > ~/.aws/credentials \
            && printf '[default]\nregion = %s\noutput = json\n' \
               '${{ secrets.S3_REGION }}' > ~/.aws/config"

      - name: Run dbt models
        env:
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          SSH="ssh -i ~/.ssh/ec2_key.pem ${{ env.SSH_OPTS }} ${{ env.EC2_USER }}@${HOST}"
          REMOTE=${{ env.REMOTE_DIR }}
          ${SSH} "set -a && source ${REMOTE}/.env && set +a && cd ${REMOTE}/car_sales_dbt && dbt run --profiles-dir . 2>&1"

      - name: Parse dbt for Dagster manifest
        env:
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          SSH="ssh -i ~/.ssh/ec2_key.pem ${{ env.SSH_OPTS }} ${{ env.EC2_USER }}@${HOST}"
          REMOTE=${{ env.REMOTE_DIR }}
          ${SSH} "set -a && source ${REMOTE}/.env && set +a && cd ${REMOTE}/car_sales_dbt && dbt parse --profiles-dir ."

      - name: Restart Dagster webserver
        env:
          HOST: ${{ secrets.EC2_HOST }}
        run: |
          SSH="ssh -i ~/.ssh/ec2_key.pem ${{ env.SSH_OPTS }} ${{ env.EC2_USER }}@${HOST}"
          REMOTE=${{ env.REMOTE_DIR }}

          # Stop existing Dagster gracefully
          ${SSH} "pkill -f 'dagster dev' || true"

          # Wait for port 3000 to be released (up to 15s)
          ${SSH} "for i in 1 2 3 4 5; do
            if ! ss -tlnp | grep -q ':3000'; then
              echo 'Port 3000 is free'
              break
            fi
            echo 'Waiting for port 3000 to be released...'
            sleep 3
          done"

          # Start Dagster
          ${SSH} "set -a && source ${REMOTE}/.env && set +a \
            && cd ${REMOTE}/car_sales_dagster \
            && nohup dagster dev -h 0.0.0.0 -p 3000 -w workspace.yaml > /tmp/dagster.log 2>&1 &"

          # Verify Dagster is responding (up to 30s)
          sleep 5
          for i in 1 2 3 4 5; do
            if curl -sf --max-time 5 "http://${{ secrets.EC2_HOST }}:3000" > /dev/null 2>&1; then
              echo "Dagster UI is up at http://${{ secrets.EC2_HOST }}:3000"
              exit 0
            fi
            echo "Waiting for Dagster to start (attempt $i)..."
            sleep 5
          done
          echo "::warning::Dagster may still be starting — check http://${{ secrets.EC2_HOST }}:3000 manually"
